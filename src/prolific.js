// Generated by CoffeeScript 1.6.3
var prolific;

prolific = (function() {
  function prolific() {
    var args, finder, getArguments, getters, matchers, preActions, runMatcher, schema, sentencer, timer, _assertions,
      _this = this;
    _assertions = null;
    schema = [];
    args = [];
    timer = 0;
    sentencer = {
      "timer": {
        reg: /^in ([\d.]+) seconds (.+)$/,
        get: "$1,$2",
        act: function(conf) {
          timer = parseFloat(conf.subjects[0], 10);
          return _assertions = conf.subjects[1];
        }
      },
      "and|or": {
        reg: /(.+) (and|or) (.+)/,
        get: "$1,$3",
        "var": "$2",
        act: function() {
          return _assertions = _assertions.split(" and ");
        }
      }
    };
    matchers = {
      "method has been called": {
        reg: /^method (.+) (is called)( with |)(.+|)$/,
        get: "$1",
        "var": "$2,$3,$4",
        act: function(conf) {
          var _m, _t;
          _t = conf.subjects[0].split(".");
          _m = _t.pop();
          eval("var _o = " + (_t.join(".")));
          spyOn(_o, _m);
          if (this.options == null) {
            throw Error("You must pass a function to execute to test if a method is called");
          }
          this.options.call(this);
          if (conf.vars[1] === "") {
            return expect(eval(conf.subjects[0])).toHaveBeenCalled();
          } else {
            return expect(eval(conf.subjects[0])).toHaveBeenCalledWith(eval(conf.vars[2]));
          }
        }
      },
      "is greater|lower than": {
        reg: /(.+) is (greater|lower|>|<) than (.+)/,
        get: "$1,$3",
        "var": "$2",
        err: function(conf) {
          var _ref;
          return "" + args[0] + " is " + ((_ref = conf.vars[0]) === "greater" || _ref === ">" ? "lower" : "greater") + " than " + args[1];
        },
        act: function(conf) {
          var num, _i, _len, _ref, _ref1;
          for (_i = 0, _len = args.length; _i < _len; _i++) {
            num = args[_i];
            if (isNaN(num)) {
              prolific.fail(conf, "" + num + " is not a number");
            }
          }
          if (((_ref = conf.vars[0]) === "greater" || _ref === ">") && (args[0] <= args[1] || args[0] > args[1] == false)) {
            prolific.fail(conf);
          }
          if (((_ref1 = conf.vars[0]) === "lower" || _ref1 === "<") && (args[0] >= args[1] || args[0] < args[1] == false)) {
            return prolific.fail(conf);
          }
        }
      },
      "is|isnt an element": {
        reg: /(.+) (is|isnt) an (element)$/,
        get: "$1",
        "var": "$2",
        act: function(conf) {
          if (args[0].size() === 0 && conf.vars[0] === "is") {
            return prolific.fail(conf);
          }
        }
      },
      "on event": {
        reg: /^on ([a-z]+) (.+) then (.+)$/,
        get: "$3",
        "var": "$1,$2",
        act: function(conf) {
          if (conf.subjects[0].indexOf("method") === 0) {
            return new prolific().test(conf.subjects[0], function() {
              return $(conf.vars[1]).trigger(conf.vars[0]);
            });
          } else {
            $(conf.vars[1]).trigger(conf.vars[0]);
            return new prolific().test(conf.subjects[0], this.options);
          }
        }
      },
      "is|isnt": {
        reg: /(.+) (is|isnt) (?!(greater than|lower than|called))(.+)/,
        get: "$1,$4",
        "var": "$2",
        err: function(conf) {
          return "" + args[0] + " " + (conf.vars[0] === "is" ? "isnt" : "is") + " " + args[1];
        },
        act: function(conf) {
          var res, testVal, _ref;
          res = (_ref = schema[0].name) === "jquery" || _ref === "jqueryshort" ? args[0].is(args[1]) === true : args[0] === args[1];
          testVal = conf.vars[0] === "isnt";
          if (res === testVal) {
            return prolific.fail(conf);
          }
        }
      }
    };
    getters = {
      math: {
        reg: /\(([0-9-+./\*\(\)]+)\)/,
        get: "$1",
        act: function(conf) {
          eval("var v = " + conf.subjects[0]);
          return v;
        }
      },
      "var": {
        reg: /(var )()/,
        get: "$2",
        act: function(conf) {
          var e;
          try {
            eval("var v = " + conf.subjects[0]);
            return v;
          } catch (_error) {
            e = _error;
            if (e.message.indexOf("undefined" > -1)) {
              return void 0;
            }
            if (e.message.indexOf("null" > -1)) {
              return null;
            }
          }
        }
      },
      reserved: {
        reg: /(null|undefined|false|true)/,
        get: "$1",
        act: function(conf) {
          if (conf.subjects[0] === "undefined") {
            return void 0;
          }
          if (conf.subjects[0] === "null") {
            return null;
          }
          if (conf.subjects[0] === "false") {
            return false;
          }
          if (conf.subjects[0] === "true") {
            return true;
          }
        }
      },
      string: {
        reg: /^'(.+)'/,
        get: "$1",
        act: function(conf) {
          return conf.subjects[0];
        }
      },
      number: {
        reg: /^([0-9.]+)$/,
        get: "$1",
        act: function(conf) {
          return parseFloat(conf.subjects[0], 10);
        }
      },
      jqueryshort: {
        reg: /^\$ (.+)$/,
        get: "$1",
        act: function(conf) {
          return $(conf.subjects[0]);
        }
      },
      jquery: {
        reg: /^\$\(["'](.+)["']\)$/,
        get: "$1",
        act: function(conf) {
          return $(conf.subjects[0]);
        }
      },
      generic: {
        reg: "",
        get: "",
        act: function(conf) {
          return conf.subjects[0];
        }
      }
    };
    /*
    method finder
    Arguments: where (string), what (array of matchers objects), callback (optional, function), multiple (boolean)
    "multiple" argument require a callback
    */

    finder = function(where, what, callback, multiple) {
      var a, b, found;
      for (a in what) {
        b = what[a];
        if (!(where.match(new RegExp(b.reg)))) {
          continue;
        }
        found = {
          source: where,
          subjects: where.replace(b.reg, b.get).split(","),
          name: a,
          item: b
        };
        if (b["var"] != null) {
          found.vars = where.replace(b.reg, b["var"]).split(",");
        }
        if (multiple !== true) {
          break;
        } else {
          callback(found);
        }
      }
      if ((callback != null) && callback !== false && multiple !== true) {
        return callback(found);
      } else {
        return found;
      }
    };
    getArguments = function() {
      var argument, index, _args, _i, _len;
      _args = [];
      for (index = _i = 0, _len = arguments.length; _i < _len; index = ++_i) {
        argument = arguments[index];
        finder(argument, getters, function(found) {
          var arg;
          if (found === void 0) {
            arg = argument;
          } else {
            arg = found.item.act(found);
          }
          _args.push(arg);
          return schema[index] = found;
        });
      }
      return _args;
    };
    runMatcher = function(matcherObj) {
      args = getArguments.apply(this, matcherObj.subjects);
      return matcherObj.item.act.call(this, matcherObj);
    };
    preActions = function() {
      var _this = this;
      finder(_assertions, sentencer, function(conf) {
        return _assertions = conf.item.act(conf);
      }, true);
      if (typeof _assertions === "string") {
        return _assertions = [_assertions];
      }
    };
    this.test = function(assumptions, options) {
      var assertion, matcherObj, _i, _len,
        _this = this;
      this.options = options;
      _assertions = assumptions;
      preActions();
      for (_i = 0, _len = _assertions.length; _i < _len; _i++) {
        assertion = _assertions[_i];
        matcherObj = finder(assertion, matchers);
        if (timer > 0) {
          waits(timer * 1000);
        }
        runs(function() {
          return runMatcher.call(_this, matcherObj);
        });
      }
      if (matcherObj === null) {
        throw Error("Can't find any test");
      }
    };
    this.getArguments = getArguments;
    this.matchers = matchers;
    this.finder = finder;
  }

  prolific.fail = function(err, params) {
    var errstr;
    errstr = "Expetation '" + err.source + "' is not met";
    if (params != null) {
      errstr += " (" + params + ")";
    }
    if (err.item.err != null) {
      errstr += " (" + (err.item.err(err)) + ")";
    }
    throw Error(errstr);
  };

  return prolific;

})();

beforeEach(function() {
  var _this = this;
  return window.assume = function(assumptions, options) {
    return runs(function() {
      return new prolific().test.call(this, assumptions, options);
    });
  };
});
